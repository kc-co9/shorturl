# 短链服务

## 概述

短链服务（`URL Shortener`）是一种可以将统一资源定位符（`URL`）缩短且仍可指向原统一资源定位符（`URL`）的技术。一般，这项技术会用在一些限制消息中字符长度、提高消息内容阅读性、或者追踪点击率等场景中，典型的有：短信消息（`SMS`）、社交媒体消息（`微博`、`小红书`等）。

## 理论

单从原理的角度看，短链服务主要是通过`URL`重定向来实现，在访问短链时会被重定向到对应的长链上。也就是说，当我们通过短链去请求时，服务器会根据短链所对应的长链对请求进行重定向，并最终将其链接到长链上，具体流程如下：

```text
          ┌───────────┐  1.request to A     ┌───────────┐
          │           ├────────────────────►│           │
          │  client   │                     │  serverA  │
          │           │◄────────────────────┤           │
          └───▲───┬───┘   2.redirect to B   └───────────┘
              │   │                                      
              │   │                                      
4.response OK │   │ 3.request to B                       
              │   │                                      
              │   │                                     
          ┌───┴───▼───┐                                  
          │           │                                  
          │ serverB   │                                  
          │           │                                  
          └───────────┘                                  
```

短链服务的原理很简单，但实现时仍然需要考虑以下`3`个关键的问题：

1. 短链的创建问题。
2. 短链的访问问题。
3. 短链的安全问题。

### 短链的创建

对于短链的创建，本质上是完成从"原始链接"到"短链"的一一映射，使得用户在访问"短链"时服务器可以在映射中找到与之对应的"原始链接"，并完成最终的重定向。在实现上，首先我们会生成一个"标识符"与"原始链接"进行绑定，然后再将已绑定的"标识符"拼接到"短链"所在的顶级域名后完成"短链"的生成。最后在对"短链"进行访问时我们会通过"短链"上"标识符"找到与之对应的"原始链接"，并完成最终的重定向了。

> 例如，在将"原始链接"与`m3q2xt`进行绑定后将其添加到"短链"所在的顶级域名`https://tinyurl.com`后完成"短链"的生成，即`https://tinyurl.com/m3q2xt` 。
 
为了能最大效率地将"原始链接"生成对应地"短链"，对"标识符"的生成策略十分关键。

#### "标识符"的策略

对于"标识符"生成策略的设计，我们应该至少需要考虑到以下三点：

- 无重复。若"标识符"的生成出现了重复的键会导致将"短链"错误地重定向到无符合预期的"原始链接"上。
- 可控的。若"标识符"的生成长度太长就违背了"短链"设计的初衷，造成生成的"短链"非短链的尴尬局面。

因此，要是我们想实现一款用在"短链"上的"标识符"生成器，最基本是要保证其生成的"标识符"是无重复和可控的。

##### 1. `HASH`算法

对于将"原始链接"映射到一个"标识符"最直接最优雅的方式当然是通过一个`HASH`算法来实现，通过这种方式在每次创建时我们只需要简单地通过`HASH`算法计算出"原始链接"对应的"标识符"即可。但是，要将一个长链接通过算法来计算出一个简短的"标识符"且要一一映射显然是不可能的。也就是说，在通过`HASH`算法将一个长链接计算出的"标识符"是会发生碰撞的，而对发生碰撞的"标识符"我们需要对其"原始链接"附加一些干扰符号后再次通过`HASH`算法计算出唯一键"，直到生成一个没有发生碰撞的"标识符"。

例如，假设我们现在需要将原始链接 `https://longurl.com/abc` 转换为断链。那我们首先会通过`HASH`算法对 `https://longurl.com/abc` 链接进行计算得出"标识符"，即：

```text
HASH(https://longurl.com/abc) => m3q2xt
```

接着，我们会查询生成的"标识符"`m3q2xt`是否已经存在，如果存在则对原始链接 `https://longurl.com/abc` 添加一些干扰符号后再次会通过`HASH`算法进行计算，在这里采用的是在原始链接前后添加`[`和`]`符号，即：

```text
HASH([https://longurl.com/abc]) => j3df2f
```

以此类推，直至生成一个没有发生碰撞的"标识符"。

> 需要注意的，在将断链解析重定向到原始链接时也需要对干扰符号进行处理，例如，在通过"标识符"查询到与之相对应的原始链接时需要去除添加的干扰符号（如有）后再进行重定向。

然而，虽然干扰符号的加入可以解决"标识符"碰撞的问题，但是对于固定长度的"标识符"生成数量确是不能无限地增长（取决于`HASH`算法），在短链不断生成的同时"标识符"的可用数量也在不断地减少，而且越到后面碰撞发生的概率就会越大。总的来说，如果`HASH`算法计算出`HASH`值的取值范围符合业务需要，我们也完全可以使用这种方式来实现短链的转换，但如果业务需要的取值范围大于`HASH`值的取值范围，则还是考虑采用其他方案更好。

##### 2. 自增`ID`算法

"标识符"的另一种天生自带无重复和可控特性的方案是自增`ID`算法。与`HASH`算法不同的是，使用自增`ID`来生成"标识符"并不会在内容上与"原始链接"建立联系，而是需要我们自己存储"原始链接"与"标识符"之间的映射。典型地，我们在短链服务中维护一个自增`ID`发号器，每当需要为"原始链接"生成"短链"时就向发号器申请一个唯一的自增`ID`，在申请获得自增`ID`后将其与"原始链接"的关系绑定在一起，最后将自增`ID`拼接到"短链"域名上返回。

不过，自增`ID`也有自身的一些问题，比如自增`ID`连续性会比较强，容易让人发现"标识符"的生成规律。在一些特定场景下，业务可能不想要将这些规律暴露给接入方或者用户，让人可以很轻易的就完成对整个"短链"库的扫描。而对于这个问题，我们也可以使用自增`ID`的一些变种来做代替方案，例如使用雪花`ID`(`Snowflake`)、`UUID`等，当然这些替代方案本身也有各自的问题（时间回拨、索引效率等问题），这需要结合各自的业务场景进行取舍和选择了。

总的来说，自增`ID`算法也能够很好地符合"短链"中"标识符"的生成策略，不过在选择前需要考虑清楚是否在意它的随机性或者其他性能上的问题。

##### 3. 线性同余算法

除此之外，我们还可以使用线性同余生成器（`LCG`）算法来生成"标识符"，通过这种方式能在无重复和可控特性的基础上附加比较好的随机性。其中，线性同余策略（`LCG`）是一个通过不连续的分段线性方程来生成伪随机数的策略，该方程属于最古老、最著名的伪随机数生成算法之一，即:

```text
X(n+1) = (a*X(n) + c) mod m
```

其中，`X(n)`表示伪随机数的值，`a`、`c`和`m`为生成器设定的整形常量，具体含义如下：

- `a`，`0 < a < m`，表示倍率
- `c`，`0 <= c < m`，表示递增量
- `m`，`0 < m`，表示模数

> 在计算第一个伪随机数时方程需要一个起始值`X(0)`，又称之为种子值或者开始值，取值范围为`0 <= X(0) < m`。

为了能完全发挥线性同余生成器（`LCG`），我们需要正确的选择合适的参数`a`、参数`c`和参数`m`，使得它可以连续生成`m`无重复的随机的"标识符"。也就是说，要高效地使用线性同余算法，不但需要我们额外去存储`Xn`，还需要正确的选择`LCG`的参数，使得它的单次生成周期能达到`m`。

总的来说，线性同余算法在无重复、可控性、随机性上都能得到比较好的效果，但是为了达到这种效果我们需要额外的存储和配置，这显然会增加业务开发和维护的整体复杂度。

#### "标识符"的缩简

为了保证"标识符"的唯一性，可能某些"标识符"的生成策略会使得生成字符长度过长，对这种场景我们可以使用`Base36`或者`Base62`进行编码（即将`10`进制数转换为`36`进制数或者`62`进制数）。例如，当我们通过某种生成策略生成"标识符"`18989844622434`，在经过`Base36`编码后"标识符"变为`6qbtb6noi`，而在经过`Base62`编码后"标识符"则变为`5okgsMqS`，可见长度都有明显地缩简。

### 短链的访问

在完成短链的创建和映射后，我们就可以将短链暴露出去。客户端在进行短链的访问时，服务器会根据短链上的标识符找到与之对应的"原始链接"，并根据不同的业务需要进行不同类型的重定向。而对于重定向，我们可以将`status`设置为`301`、`302`、`303`、`307`和`308`来实现，具体差异如下所示：

| 状态码   | 状态码定义                | 描述                                                                                                                                                                         |
|-------|----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `301` | `Moved Permanently`  | 永久重定向。`301`表示目标资源已被永久地指派到新到`URI`上，后续对目标资源的引用都应该使用新的`URI`。因为历史的原因，在重定向的请求中可以将`POST`请求转变为`GET`请求。                                                                            |
| `302` | `Found`              | 临时重定向。`302`表示目标资源临时存放在不同的`URI`上，后续对目标资源的引用应该还是使用原本的有效`URI`（后续重定向的`URI`可能会发生变化）。因为历史的原因，在重定向的请求中可以将`POST`请求转变为`GET`请求。                                                      |
| `303` | `See Other`          | 临时重定向。`303`表示服务器要将终端重定向到不同的`URI`上，以实现向原始请求提供一个间接的响应（终端可以通过`GET`方法或者`HEAD`方法请求原始响应上的不同的`URI`（可能会发生重定向）并以此作为原始请求的结果），例如，在通过`POST`方法上传一些文件后，服务器发回一个`303`响应将终端重定向到一个“上传成功”的页面。 |
| `307` | `Temporary Redirect` | 临时重定向，`307`表示目标资源临时存放在不同的`URI`上，后续对目标资源的引用应该还是使用原本的有效`URI`（后续重定向的`URI`可能会发生变化）。相比于`302`，`307`不允许在重定向的请求中将`POST`请求转变为`GET`请求。                                               |
| `308` | `Permanent Redirect` | 永久重定向。`308`表示目标资源已被永久地指派到新到`URI`上，后续对目标资源的引用都应该使用新的`URI`。相比于`301`，`308`不允许在重定向的请求中将`POST`请求转变为`GET`请求。                                                                     |

### 短链的安全

短链技术在某种程度说会遮盖了真实请求的目标地址，在访问时用户可能会被重定向到一个预期之外的网站，例如一些诈骗网站、含恶意软件或者带`XSS`攻击的网站等。而因为短链技术，通过将这些网站加入到`blocklists`来阻止访问的方式也完全地绕开了。这样的安全威胁对某些服务商来说显然是不可接收的，因此这些服务商也会对某些短链限制访问。

当然，一些短链服务商也为此想出了一些方式来防止或者提醒用户进入这些危险的网站，比如通过提供一个选项去让终端或者用户预览短链最终的指向的目的地址。除此之外，终端或者用户还可以通过`bad-site`筛选服务（例如`Google Safe Browsing`）来预防短链重定向时进入危险网站。

> 典型地，可在短链地址加上前缀路由`preview`来实现目的地址的预览，即在短链地址 `https://tinyurl.com/8kmfp` 加上前缀路由 `preview` 构造出 `https://preview.tinyurl.com/8kmfp` 来实现目的地址的预览。

## 设计

## 参考

- [Wiki《URL shortening》](https://en.wikipedia.org/wiki/URL_shortening)
- [Wiki《Hash function》](https://en.wikipedia.org/wiki/Hash_function)
- [Wiki《Non-cryptographic hash function》](https://en.wikipedia.org/wiki/Non-cryptographic_hash_function)
- [Wiki《Cryptographic hash function》](https://en.wikipedia.org/wiki/Cryptographic_hash_function)
- [Wiki《MurmurHash》](https://en.wikipedia.org/wiki/MurmurHash)
- [Wiki《Base36》](https://en.wikipedia.org/wiki/Base36)
- [Wiki《Base62》](https://en.wikipedia.org/wiki/Base62)
- [RFC7231《Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content》](https://datatracker.ietf.org/doc/html/rfc7231)
- [RFC7538《The Hypertext Transfer Protocol Status Code 308 (Permanent Redirect)》](https://datatracker.ietf.org/doc/html/rfc7538)
- [知乎《短URL系统是怎么设计的？》](https://www.zhihu.com/question/29270034)
- [知乎《HTTP 中的 301、302、303、307、308 响应状态码 》](https://zhuanlan.zhihu.com/p/60669395)